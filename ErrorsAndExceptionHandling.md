# Errors and exception handling

## Swift
Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime. In Swift, errors are represented by values of types that conform to the *Error* protocol. This empty protocol indicates that a type can be used for error handling. 

There are four ways to handle errors in Swift: You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. 

```swift
var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8

do {
  try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
  print("Success! Yum.")
} catch VendingMachineError.invalidSelection {
  print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
  print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
  print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
} catch {
  print("Unexpected error: \(error).")
}
// Prints "Insufficient funds. Please insert an additional 2 coins."

```

## Java
All exception classes are subtypes of the `java.lang.Exception class`. The exception class is a subclass of the *Throwable* class. Other than the exception class there is another subclass called *Error* which is derived from the *Throwable* class. 

> Errors are abnormal conditions that happen in case of severe failures, these are not handled by the Java programs. Errors are generated to indicate errors generated by the runtime environment.

```java
try {
  file = new FileInputStream(fileName);
  x = (byte) file.read();
} catch (IOException i) {
  i.printStackTrace();
  return -1;
} catch (FileNotFoundException f) // Not valid! {
  f.printStackTrace();
  return -1;
}
```
